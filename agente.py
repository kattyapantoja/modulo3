# -*- coding: utf-8 -*-
"""Tarea Final Modulo 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T2dnwc3cYKWJ0Ro4zQ4ebXAREfOv141w

# Asistente Gastronómico con LangChain
Proyecto Modulo 1 - Agente Inteligente para Emprendedores Gastronómicos
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install --upgrade --quiet youtube_search
# %pip install --upgrade --quiet langchain-community

pip install pymupdf youtube-search-python

pip install langchain langchain_openai langchain-community langgraph unstructured pdfminer.six elasticsearch langchain_elasticsearch

import os
os.environ['OPENAI_API_KEY'] = "openai_key"
os.environ["TAVILY_API_KEY"] = "tavily_key"

from langchain.agents import create_react_agent, AgentExecutor
from langchain import hub
from langchain.tools import Tool
from langchain.memory import ConversationBufferMemory
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate
from langchain_community.tools.tavily_search import TavilySearchResults
from langchain_openai import OpenAIEmbeddings
from langchain_community.document_loaders import UnstructuredPDFLoader

with open("reglas_empleados.txt") as archivo:
    reglas = archivo.read()

import pandas as pd
from datetime import datetime, timedelta

productos_df = pd.read_csv("productos_kattys.csv")
pedidos_df = pd.read_csv("pedidos_programados.csv")
recetas_df = pd.read_csv("recetas_katty.csv")
inventario_df = pd.read_csv("inventario_katty.csv")
precios_df = pd.read_csv("insumos_con_precios.csv")

base_prompt = hub.pull("hwchase17/react")

llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)

# Crea un nuevo prompt con reglas + prompt base
prompt = PromptTemplate(
    template="Siempre responde en español.\n\n" + reglas + "\n\n" + base_prompt.template,
    input_variables=base_prompt.input_variables
)

import fitz  # PyMuPDF
import json
from langchain_core.documents import Document

# Cargar y convertir PDF a objetos Document de LangChain
def load_pdf_as_documents(filepath, titulo, categoria, origen, idioma):
    pdf = fitz.open(filepath)
    docs = []
    for i, page in enumerate(pdf):
        text = page.get_text()
        if text.strip():
            docs.append(Document(
                page_content=text,
                metadata={
                    "page": i + 1,
                    "categoria": categoria,
                    "idioma": "es",
                    "origen": origen,
                    "titulo": titulo
                }
            ))
    return docs

docs_horno = load_pdf_as_documents(
    filepath="Manual_uso_de_horno.pdf",
    titulo="Manual de Uso del Horno",
    categoria="uso_horno",
    origen="miele",
    idioma="es"
)
docs_practicas = load_pdf_as_documents(
    filepath="Guia_de_buenas_practicas_de_higiene_en_establecimientos.pdf",
    titulo="Buenas Practicas de Higiene",
    categoria="buenas_practicas",
    origen="gob.mx",
    idioma="es"
)

from langchain_community.document_loaders import WebBaseLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_elasticsearch import ElasticsearchStore
from langchain.chains import RetrievalQA
from langchain_core.runnables import RunnableBranch, RunnableLambda

# Split
text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
chunks_practicas = text_splitter.split_documents(docs_practicas)
chunks_horno = text_splitter.split_documents(docs_horno)

# Embeddings
embeddings = OpenAIEmbeddings(model="text-embedding-3-large")

# Crear vector_store e indexar documentos
vector_store = ElasticsearchStore.from_documents(
    documents=chunks_horno + chunks_practicas,
    embedding=embeddings,
    es_url="http://34.70.64.227:9200",
    es_user="elastic",
    es_password="j67jdedrzUivAfkhrkI7",
    index_name="indx_02"
)

# Refrescar índice
vector_store.client.indices.refresh(index="indx_02")

retriever_horno = ElasticsearchStore(
    es_url="http://34.70.64.227:9200",
    es_user="elastic",
    es_password="j67jdedrzUivAfkhrkI7",
    index_name="indx_02",
    embedding=embeddings
).as_retriever(search_kwargs={
    "filter": [
        {"term": {"categoria": "uso_horno"}}
    ]
})

retriever_buenas_practicas = ElasticsearchStore(
    es_url="http://34.70.64.227:9200",
    es_user="elastic",
    es_password="j67jdedrzUivAfkhrkI7",
    index_name="indx_02",
    embedding=embeddings
).as_retriever(search_kwargs={
    "filter": [
        {"term": {"categoria": "buenas_practicas"}}
    ]
})

# Nuevo prompt específico para respuestas amplias
qa_prompt = PromptTemplate(
    input_variables=["context", "question"],
    template="""
Eres un experto en normas de higiene y uso de hornos profesionales. Responde SIEMPRE en español.
Basado en la siguiente información del manual o la guía, responde con detalle a la pregunta.

=== CONTEXTO ===
{context}

=== PREGUNTA ===
{question}

=== RESPUESTA EN ESPAÑOL ===
"""
)

# Nueva cadena con el prompt personalizado
qa_chain_horno = RetrievalQA.from_chain_type(
    llm=llm, retriever=retriever_horno, return_source_documents=True,
    chain_type_kwargs={"prompt": qa_prompt}
)

qa_chain_buenas = RetrievalQA.from_chain_type(
    llm=llm, retriever=retriever_buenas_practicas, return_source_documents=True,
    chain_type_kwargs={"prompt": qa_prompt}
)

def consultar_manual_horno(pregunta):
    result = qa_chain_horno.invoke({"query": pregunta})
    return result["result"]

def consultar_buenas_practicas(pregunta):
    result = qa_chain_buenas.invoke({"query": pregunta})
    return result["result"]

def calcular_costos(params):
    if isinstance(params, str):
        # Buscar el producto dentro de una frase usando heurística simple
        productos_disponibles = recetas_df["producto"].unique()
        producto = next((p for p in productos_disponibles if p.lower() in params.lower()), None)
        if not producto:
            return "No pude identificar el producto. Por favor especifica uno existente."
    elif isinstance(params, dict):
        producto = params.get("producto")
        if not producto:
            return "Debes especificar el nombre del producto."
    else:
        return "Formato no válido. Debes proporcionar el nombre del producto."

    ingredientes = recetas_df[recetas_df['producto'] == producto]
    if ingredientes.empty:
        return f"No se encontró receta para el producto '{producto}'."

    total = 0
    detalles = []
    faltantes = []

    for _, fila in ingredientes.iterrows():
        insumo = fila["insumo"]
        cantidad = fila["cantidad"]

        fila_precio = precios_df[precios_df['insumo'] == insumo]
        if fila_precio.empty:
            faltantes.append(insumo)
            continue

        precio_unitario = fila_precio.iloc[0]["precio_unitario"]
        costo = cantidad * precio_unitario
        total += costo
        detalles.append(f"{insumo}: {cantidad} x S/{precio_unitario:.2f} = S/{costo:.2f}")

    if faltantes:
        return f"Faltan precios para los siguientes insumos:\n- " + "\n- ".join(faltantes)

    precio_sugerido = round(total * 1.5, 2)

    return f"""Costo total estimado: S/{total:.2f}
Precio sugerido de venta (margen 50%): S/{precio_sugerido:.2f}

Desglose:
""" + "\n".join(detalles)


def ver_productos_con_stock_bajo(_input=None):
    bajo_stock = inventario_df[inventario_df['cantidad_actual'] < inventario_df['cantidad_minima']]
    if bajo_stock.empty:
        return "Todos los insumos están en niveles adecuados."
    return "Insumos con stock bajo:\n" + "\n".join([
        f"- {row['insumo']}: {row['cantidad_actual']} unidades (mínimo: {row['cantidad_minima']})"
        for _, row in bajo_stock.iterrows()
    ])


import re
def ver_pedidos_programados(fecha_str=None):
    if isinstance(fecha_str, dict) and "fecha" in fecha_str:
        fecha_str = fecha_str["fecha"]
    elif isinstance(fecha_str, str):
        # Buscar una fecha tipo AAAA-MM-DD dentro del texto
        match = re.search(r"\d{4}-\d{2}-\d{2}", fecha_str)
        if match:
            fecha_str = match.group()
        else:
            return "No se encontró una fecha válida. Usa el formato AAAA-MM-DD."

    if fecha_str:
        try:
            filtrado = pedidos_df[pedidos_df['fecha_entrega'] == fecha_str]
        except ValueError:
            return "Fecha no válida. Usa el formato AAAA-MM-DD. Ejemplo: 2025-05-13"
    else:
        filtrado = pedidos_df

    if filtrado.empty:
        return "No hay pedidos programados para esa fecha." if fecha_str else "No hay pedidos programados."

    return "Pedidos programados:\n" + "\n".join([
        f"- {row['cliente']} - {row['producto']} ({row['fecha_entrega']}) - {row['estado']}"
        for _, row in filtrado.iterrows()
    ])

tavily = TavilySearchResults()

tool_tavily = Tool(
    name="buscar_en_la_web",
    func=tavily.run,
    description="Busca información actualizada y precisa en internet sobre productos o ingredientes o tendencias actuales en el mercado."
)

#youtube
from langchain_community.tools import YouTubeSearchTool
youtube = YouTubeSearchTool()

import smtplib
from email.mime.text import MIMEText

def enviar_por_correo(params):
    # Asegurar que 'params' sea un diccionario (por si vino como string JSON)
    if isinstance(params, str):
        try:
            params = json.loads(params)
        except:
            return "⚠️ Error: El formato del input no es válido."

    destinatario = params.get("destinatario")
    asunto = params.get("asunto", "Sin asunto")
    mensaje = params.get("mensaje", "")

    if not destinatario:
        return "Falta el destinatario del correo."

    # Configura tus credenciales
    remitente = "kattya.pantoja.a@gmail.com"
    contraseña = "sswt iujq horz fimi"

    msg = MIMEText(mensaje, "plain", "utf-8")
    msg["Subject"] = asunto
    msg["From"] = remitente
    msg["To"] = destinatario

    try:
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(remitente, contraseña)
        server.sendmail(remitente, destinatario, msg.as_string())
        server.quit()
        return f"📨 Correo enviado correctamente a {destinatario}."
    except Exception as e:
        return f"❌ Error al enviar el correo: {e}"

tools_inventario = [
    Tool(name="ver_productos_con_stock_bajo",func=ver_productos_con_stock_bajo,description="Muestra los insumos con niveles de stock por debajo del mínimo recomendado.")
    ]
tools_costos = [
    Tool(name="calcular_costos", func=calcular_costos, description="Calcula el costo de un producto"),
    ]
tools_pedidos = [
    Tool(name="ver_pedidos_programados", func=ver_pedidos_programados, description="Muestra los pedidos programados, se puede ingresar una fecha AAAA-MM-DD")
    ]
tools_consultas = [
    Tool(name="consultar_buenas_practicas",func=consultar_buenas_practicas,description="Consulta normas de higiene incluyendo la guía oficial del gobierno ."),
    Tool(name="consultar_manual_horno",func=consultar_manual_horno,description="Consulta procedimientos técnicos relevantes para el negocio, incluyendo el manual de uso del horno profesional.")
    ]
tools_busqueda_externa = [
    Tool(name="youtube_search", func=lambda q: youtube.run(q), description="Busca videos en YouTube relacionados con un tema"),
    Tool(name="buscar_web", func=tool_tavily.run, description="Busca información actualizada y precisa en internet sobre recetas, productos o ingredientes.")
    ]
tools_comunicacion = [
    Tool(
        name="enviar_por_correo",
        func=enviar_por_correo,
        description="Envía un mensaje real por correo electrónico. Requiere destinatario, asunto y mensaje."
    )
]
tools_videos = [
    Tool(
        name="enlaces_de_videos_sobre",
        func=lambda q: tavily.run(f"{q} site:youtube.com"),
        description="Devuelve enlaces de YouTube sobre recetas, postres o técnicas de decoración."
    )
]

# Definir los diferentes agentes
agent_inventario = create_react_agent(llm=llm, tools=tools_inventario, prompt=prompt)
agent_costos = create_react_agent(llm=llm, tools=tools_costos, prompt=prompt)
agent_pedidos = create_react_agent(llm=llm, tools=tools_pedidos, prompt=prompt)
agent_consultas = create_react_agent(llm=llm, tools=tools_consultas, prompt=prompt)
agent_busqueda_externa = create_react_agent(llm=llm, tools=tools_busqueda_externa, prompt=prompt)
agent_comunicacion = create_react_agent(llm=llm, tools=tools_comunicacion, prompt=prompt)
agent_videos = create_react_agent(llm=llm, tools=tools_videos, prompt=prompt)

# Memoria para cada agente
memory_inventario = ConversationBufferMemory(memory_key="chat_history_inventario")
memory_costos = ConversationBufferMemory(memory_key="chat_history_costos")
memory_pedidos = ConversationBufferMemory(memory_key="chat_history_pedidos")
memory_consultas = ConversationBufferMemory(memory_key="chat_history_consultas")
memory_busqueda_externa = ConversationBufferMemory(memory_key="chat_history_busqueda_externa")
memory_comunicacion = ConversationBufferMemory(memory_key="chat_history_comunicacion")

# Ejecutar los agentes por separado
executor_inventario = AgentExecutor(agent=agent_inventario, tools=tools_inventario, memory=memory_inventario, output_key="output")
executor_costos = AgentExecutor(agent=agent_costos, tools=tools_costos, memory=memory_costos, output_key="output")
executor_pedidos = AgentExecutor(agent=agent_pedidos, tools=tools_pedidos, memory=memory_pedidos, output_key="output")
executor_consultas = AgentExecutor(agent=agent_consultas, tools=tools_consultas, memory=memory_consultas, output_key="output")
executor_busqueda_externa = AgentExecutor(agent=agent_busqueda_externa, tools=tools_busqueda_externa, memory=memory_busqueda_externa, output_key="output")
executor_comunicacion = AgentExecutor(agent=agent_comunicacion, tools=tools_comunicacion, memory=memory_comunicacion, output_key="output")
executor_videos = AgentExecutor(agent=agent_videos, tools=tools_videos, memory=ConversationBufferMemory(memory_key="chat_history_videos"), output_key="output")

def redirigir_a_agente(input):
    texto = input["input"].lower()
    if "stock" in texto or "insumos" in texto or "compras" in texto:
        return executor_inventario
    elif "pedido" in texto or "entrega" in texto:
        return executor_pedidos
    elif "precio" in texto or "cuánto" in texto or "costos" in texto:
        return executor_costos
    elif "horno" in texto or "manual" in texto or "higiene" in texto or "normas" in texto:
        return executor_consultas
    elif "video" in texto or "youtube" in texto or "ver" in texto:
      return executor_videos
    else:
        return executor_busqueda_externa  # fallback

# Crear el controlador con dos ramas:
# - Rama 1: siempre evalúa como True y llama a redirigir_a_agente
# - Rama 2: valor por defecto (por si falla todo)
agente_controlador = RunnableBranch(
    (lambda x: True, RunnableLambda(redirigir_a_agente)),
    RunnableLambda(lambda x: {"output": "Lo siento, no entendí tu consulta."})
)

def ofrecer_envio_por_correo(texto, sugerencia="¿Quieres que te lo envíe por correo?"):
    return f"""{texto}

📩 {sugerencia} Responde con "sí, envíalo a [correo]" para enviártelo."""

import json
def manejar_respuesta_usuario(texto_usuario, ultimo_resultado):
    if "envíalo a" in texto_usuario.lower():
        match = re.search(r"envíalo a ([\w\.-]+@[\w\.-]+\.\w+)", texto_usuario.lower())
        if match:
            correo = match.group(1)
            return executor_comunicacion.invoke({
    "input": json.dumps({
        "destinatario": correo,
        "asunto": "Información solicitada",
        "mensaje": ultimo_resultado
    })
})
        else:
            return "⚠️ No encontré un correo válido en tu mensaje."
    return "👍 ¡Entendido!"

print("\n--- Asistente Gastronómico Activado ---\n")